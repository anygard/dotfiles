#!/bin/bash

# 
# This script wrapps ansible-playbook and allows the same command to be run on
# multiple hosts att once
#

verbose=
user=
timeout=
sudo=
hostfile=

function usage() {
        echo "Usage: $(basename $0) [-v|--verbose] [-p|--password] [-h | --hostfile HOSTFILE] [-s|--sudo] [-g|--setuser TARGETUSER] [-u|--user LOGINUSER] [-t|--timeout TIMEOUT] [-i|--inventory INVENTORY] [-l|--limit LIMIT] <hosts> <command line>"
	echo "          <command line> is a complete command enclosed in \"s"
	echo "          <hosts> is a commmaseparated list of hosnames eg. L001234,L001235"
	echo
	echo "Example:"
	echo "		$(basename $0) -u foo -s  \"lsblk | grep sdb\" L001234,L001235"
	echo
        exit 1
}

function ci2fqdn() {
        CI=$(echo $1 |  tr '[:lower:]' '[:upper:]')
        domains=""
        suffix=ams.se
        for a in wpa ata upa udmz admz wdmz wp wt wu ws tdm; do
                domains="$domains $a.$suffix"
        done
        domains="$domains dmz.i1.local i1.local u1.local"

        for d in $domains ; do
                FQDN="$CI.$d"
                if host $FQDN &> /dev/null ; then
                        echo $FQDN
                        return 0
                fi
        done
        echo "no fqdn"
}

function create_inv_file {
	func=$1
	hostsrc=$2
	invtmp=$3

	case "$func" in
	csl)
		hostlist=$(echo $hostsrc | tr "," "\n")
		;;
	file)
		hostlist=$(cat $hostsrc)
		;;
	*)
		echo "Broken on so many levels"
		esac

	for h in $hostlist ; do 
		fqdn=$(ci2fqdn $h)
		if echo $fqdn | grep 'no fqdn'; then
			echo "$h does not seem to be a valid host"
                else
			if [ -n "$fqdn" ]; then
				echo $fqdn >> $invtmp
			fi
		fi
	done
}

opts=$(getopt -o "vsph:t:u:g:f:i:l:" -l "verbose,sudo,password,hostfile:,timeout:,user:,setuser:,forks,inventory,limit:" -n $(basename $0) -- "$@" )
if [ $? != 0 ] ; then
        usage
fi
eval set -- "$opts"

while true ; do
        case "$1" in
                -v | --verbose)
                        verbose="-vvv"
                        shift
                        ;;

                -s | --sudo)
                        become="--become --ask-become-pass"
                        shift
                        ;;

                -p | --password)
                        password="--ask-pass"
                        shift
                        ;;

                -g | --setuser)
                        become="--become --ask-become-pass --become-method=su --become-user=$2"
                        shift 2
                        ;;

                -u | --user)
                        user="--user $2"
                        shift 2
                        ;;

                -h | --hostfile)
                        hostfile="$2"
                        shift 2
                        ;;

                -i | --inventory)
                        invfname="$2"
                        shift 2
                        ;;

                -l | --limit)
                        limit="--limit $2"
                        shift 2
                        ;;

                -t | --timeout)
                        timout="--timeout $2"
                        shift 2
                        ;;

                -f | --forks)
                        forks="--forks $2"
                        shift 2
                        ;;

                --)
                        shift
                        break
                        ;;

                *)
                        echo "Unexpected error"
			exit 2
                        ;;

        esac
done

if [ -z "$invfname" -a ! -f "$invfname" ] ; then
	invtmp=$(mktemp)
	if [ -z "$hostfile" ]; then
		if [ $# -lt 2 ]; then
			usage
		fi
		hosts=$1
		cmdline=$2
		create_inv_file 'csl' "$hosts" "$invtmp"
	else
		if [ $# -lt 1 ] && [ ! -f $hostname ]; then
			usage
		fi
		cmdline=$1
		create_inv_file 'file' "$hostfile" "$invtmp"
	fi
else
	invtmp=$invfname
	cmdline=$1
fi

export ANSIBLE_HOST_KEY_CHECKING=False

if [ -n "$verbose" ] ; then
	echo
	cat $invtmp
	echo
	setx='set -x'
fi

$setx
ansible all $verbose $password $user --inventory-file=$invtmp $timeout $become $forks $limit --module-name shell --args "$cmdline" --module-name raw 
set +x

if [ -z "$invfname" ] ; then 
	rm $invtmp
fi
